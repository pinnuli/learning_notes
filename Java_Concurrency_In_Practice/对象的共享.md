### 一、可见性

#### 非原子的64位操作
- 对于非volatile类型的long和double变量，JVM允许将来64位的读操作或写操作分解为两个32位的操作，如果该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位
- 在多线程中使用共享且可变的long和double等类型变量是不安全的，需要用volatile声明或加锁
#### 加锁与可见性
- 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享可变变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。
#### Volatile变量
一种稍弱的同步机制，用来确保将变量的更新操作通知到其他线程
- 从内存可见性的角度来看，写入volatile变量相当于退出同步代码块，读取volatile变量相当于进入同步代码块
- 当volatile变量能简化代码的实现以及对同步策略的验证时才使用
- 加锁机制既可以确保可见性又可以确保原子性，volatile变量只能确保可见性（因此不足以确保递增操作的原子性）
- 当且仅当满足以下所有条件时，才应该使用volatile变量：
    1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值
    2.变量不需要与其他的状态变量共同参与不变约束
    3.在访问变量时不需要加锁
- volatile的适用场景：
    1.作为状态标志：
    ```java
    volatile boolean asleep;
    ...
    while(!asleep){
        countSomeSheep();
    }
    ```
    2.一次性安全发布:
    ```java
    public class Singleton {

        private Singleton() {}

        private static volatile Singleton instance = null;

        public static Singleton getInstance() {
            if (instance == null) { // 双重检测机制        
                synchronized (Singleton.class) { // 同步锁
                    if (instance == null) {
                        instance = new Singleton(); 
                    }
                }
            }
            return instance;
        }
    }
    ```
### 发布与逸出

