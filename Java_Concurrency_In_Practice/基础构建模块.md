### 同步容器类
#### 常见的同步容器
- ArrayList -> Vecotr
- HashMap -> Hashtable
- Collections.synchronizedXXX

#### 同步容器并不是在任何情况下都能线程安全
- 导致混乱结果的符合操作
```java
    public static Object getLast(Vector list) {
        int lastIndex = list.siaze() - 1;
        return list.get(lastIndex);
    }

    public static void deleteLast(Vector list) {
        int lastIndex = list.siaze() - 1;
        list.remove(lastIndex);
    }
```

> 如果线程A 在包含10 个元素的Vector 上调用getLast, 同时线程B 在同一个Vector 上调用deleteLast, 这些操作的交替执行如图所示， getLast 将抛出ArraylndexOutOffioundsException 异常。在调用size与调用getLast 这两个操作之间， Vector 变小了， 因此在调用size 时得到的索引值将不再有效。这种情况很好地遵循了Vector 的规范一一如果请求一个不存在的元素， 那么将抛出一个异常
![](images/java_concurrency_synchronizedContainer_threadAB.png)

解决方法：在容器上加锁
```java
    public static Object getLast(Vector list) {
        synchronized(list) {
            int lastIndex = list.siaze() - 1;
            return list.get(lastIndex);
        }
    }
```

- 迭代操作抛出ArrayIndexOutOfBoundsException异常
```java
    for (int i = 0; i < vector.size(); i++) {
        doSomething(vector.get(i));
    }
```
> 如果在对Vector进行迭代时， 另一个线程删除了一个元素， 并且这两个操作交替执行， 那么这种迭
代方法将抛出ArrayindexOutOfBoundsException异常。
解决方法：在容器上加锁
```java
    synchronized(vector) {
        for (int i = 0; i < vector.size(); i++) {
        doSomething(vector.get(i));
        }
    }
```

- 迭代器与ConcurrentModificationException
无论在直接迭代还是在Java5.0引入的for-each循环语法中，对容器类进行迭代的标准方式都是使用Iterator, 然而， 如果有其他线程并发地修改容器， 那么即使是使用迭代器也无法避免在迭代期间对容器加锁。在设计同步容器类的迭代器时并没有考虑到并发修改的问题， 并且它们表现出的行为是“ 及时失败" (fail-fast)的。这种“ 及时失败” 的迭代器井不是一种完备的处理机制，而只是“ 善意地” 捕获并发错误，因此只能作为并发问题的预警指示器。它们采用的实现方式是，将计数器的变化与容器关联起来： 如果在迭代期间计数器被修改， 那么hasNext或next将抛出ConcurrentModificationException。

```java
    List<Widget> widgetList = Collections.synchronizedList(new ArrayList<Wedget>);
    for (Widget w : widgetList) {
        doSomething(w);
    }
```
解决方法：
1. 可以通过持有容器的锁来避免出现这个异常
2. 如果不希望在迭代期间对容器加锁， 那么一种替代方法就是“ 克隆” 容器， 并在副本上进行迭代。
> 在遍历容器的过程中(不管是不是线程安全的容器），特别是使用foreach和iterator时，尽量不要对容器进行删除等更新操作，可以遍历过程中做好标记，等遍历结束后再进行处理.

----

### 并发容器
----
### 阻塞队列
----
### 同步工具类